<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 4 Behavioral Complexities | Point count data analysis: How to violate assumptions and get away with it</title>
  <meta name="description" content="This book provides material for the workshop ‘Analysis of point-count data in the presence of variable survey methodologies and detection error’ at the AOS 2019 conference." />
  <meta name="generator" content="bookdown 0.11 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 4 Behavioral Complexities | Point count data analysis: How to violate assumptions and get away with it" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://peter.solymos.org/qpad-book/" />
  <meta property="og:image" content="http://peter.solymos.org/qpad-book/images/cover.png" />
  <meta property="og:description" content="This book provides material for the workshop ‘Analysis of point-count data in the presence of variable survey methodologies and detection error’ at the AOS 2019 conference." />
  <meta name="github-repo" content="psolymos/qpad-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 4 Behavioral Complexities | Point count data analysis: How to violate assumptions and get away with it" />
  
  <meta name="twitter:description" content="This book provides material for the workshop ‘Analysis of point-count data in the presence of variable survey methodologies and detection error’ at the AOS 2019 conference." />
  <meta name="twitter:image" content="http://peter.solymos.org/qpad-book/images/cover.png" />

<meta name="author" content="Peter Solymos" />


<meta name="date" content="2019-06-13" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="regression.html">
<link rel="next" href="detection.html">
<script src="libs/jquery/jquery.min.js"></script>
<link href="libs/gitbook/css/style.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">QPAD Book</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#about-the-book-and-the-course"><i class="fa fa-check"></i>About the book and the course</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#about-the-author"><i class="fa fa-check"></i>About the author</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#installing-r-and-rstudio"><i class="fa fa-check"></i>Installing R and RStudio</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#installing-required-packages"><i class="fa fa-check"></i>Installing required packages</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#installing-the-book"><i class="fa fa-check"></i>Installing the book</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#how-this-works"><i class="fa fa-check"></i>How this works</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#acknowledgments"><i class="fa fa-check"></i>Acknowledgments</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#design-based-approaches"><i class="fa fa-check"></i><b>1.1</b> Design-based approaches</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#model-based-approaches"><i class="fa fa-check"></i><b>1.2</b> Model-based approaches</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#our-approach"><i class="fa fa-check"></i><b>1.3</b> Our approach</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="pcdata.html"><a href="pcdata.html"><i class="fa fa-check"></i><b>2</b> Organizing and Processing Point Count Data</a><ul>
<li class="chapter" data-level="2.1" data-path="pcdata.html"><a href="pcdata.html#introduction"><i class="fa fa-check"></i><b>2.1</b> Introduction</a></li>
<li class="chapter" data-level="2.2" data-path="pcdata.html"><a href="pcdata.html#prerequisites"><i class="fa fa-check"></i><b>2.2</b> Prerequisites</a></li>
<li class="chapter" data-level="2.3" data-path="pcdata.html"><a href="pcdata.html#rbasics"><i class="fa fa-check"></i><b>2.3</b> R basics</a></li>
<li class="chapter" data-level="2.4" data-path="pcdata.html"><a href="pcdata.html#josm-data-set"><i class="fa fa-check"></i><b>2.4</b> JOSM data set</a></li>
<li class="chapter" data-level="2.5" data-path="pcdata.html"><a href="pcdata.html#cross-tabulating-species-counts"><i class="fa fa-check"></i><b>2.5</b> Cross tabulating species counts</a></li>
<li class="chapter" data-level="2.6" data-path="pcdata.html"><a href="pcdata.html#joining-species-data-with-predictors"><i class="fa fa-check"></i><b>2.6</b> Joining species data with predictors</a></li>
<li class="chapter" data-level="2.7" data-path="pcdata.html"><a href="pcdata.html#explore-predictor-variables"><i class="fa fa-check"></i><b>2.7</b> Explore predictor variables</a></li>
<li class="chapter" data-level="2.8" data-path="pcdata.html"><a href="pcdata.html#derived-variables"><i class="fa fa-check"></i><b>2.8</b> Derived variables</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="regression.html"><a href="regression.html"><i class="fa fa-check"></i><b>3</b> A Primer in Regression Techniques</a><ul>
<li class="chapter" data-level="3.1" data-path="regression.html"><a href="regression.html#introduction-1"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="regression.html"><a href="regression.html#prerequisites-1"><i class="fa fa-check"></i><b>3.2</b> Prerequisites</a></li>
<li class="chapter" data-level="3.3" data-path="regression.html"><a href="regression.html#poisson-null-model"><i class="fa fa-check"></i><b>3.3</b> Poisson null model</a></li>
<li class="chapter" data-level="3.4" data-path="regression.html"><a href="regression.html#exploring-covariates"><i class="fa fa-check"></i><b>3.4</b> Exploring covariates</a></li>
<li class="chapter" data-level="3.5" data-path="regression.html"><a href="regression.html#single-covariate"><i class="fa fa-check"></i><b>3.5</b> Single covariate</a></li>
<li class="chapter" data-level="3.6" data-path="regression.html"><a href="regression.html#additive-model"><i class="fa fa-check"></i><b>3.6</b> Additive model</a></li>
<li class="chapter" data-level="3.7" data-path="regression.html"><a href="regression.html#nonlinear-terms"><i class="fa fa-check"></i><b>3.7</b> Nonlinear terms</a></li>
<li class="chapter" data-level="3.8" data-path="regression.html"><a href="regression.html#categorical-variables"><i class="fa fa-check"></i><b>3.8</b> Categorical variables</a></li>
<li class="chapter" data-level="3.9" data-path="regression.html"><a href="regression.html#multiple-main-effects"><i class="fa fa-check"></i><b>3.9</b> Multiple main effects</a></li>
<li class="chapter" data-level="3.10" data-path="regression.html"><a href="regression.html#interaction"><i class="fa fa-check"></i><b>3.10</b> Interaction</a></li>
<li class="chapter" data-level="3.11" data-path="regression.html"><a href="regression.html#different-error-distributions"><i class="fa fa-check"></i><b>3.11</b> Different error distributions</a></li>
<li class="chapter" data-level="3.12" data-path="regression.html"><a href="regression.html#count-duration-effects"><i class="fa fa-check"></i><b>3.12</b> Count duration effects</a></li>
<li class="chapter" data-level="3.13" data-path="regression.html"><a href="regression.html#count-radius-effects"><i class="fa fa-check"></i><b>3.13</b> Count radius effects</a></li>
<li class="chapter" data-level="3.14" data-path="regression.html"><a href="regression.html#offsets"><i class="fa fa-check"></i><b>3.14</b> Offsets</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="behavior.html"><a href="behavior.html"><i class="fa fa-check"></i><b>4</b> Behavioral Complexities</a><ul>
<li class="chapter" data-level="4.1" data-path="behavior.html"><a href="behavior.html#introduction-2"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="behavior.html"><a href="behavior.html#prerequisites-2"><i class="fa fa-check"></i><b>4.2</b> Prerequisites</a></li>
<li class="chapter" data-level="4.3" data-path="behavior.html"><a href="behavior.html#birds-in-the-forest"><i class="fa fa-check"></i><b>4.3</b> Birds in the forest</a></li>
<li class="chapter" data-level="4.4" data-path="behavior.html"><a href="behavior.html#survival-model"><i class="fa fa-check"></i><b>4.4</b> Survival model</a></li>
<li class="chapter" data-level="4.5" data-path="behavior.html"><a href="behavior.html#vocalization-events"><i class="fa fa-check"></i><b>4.5</b> Vocalization events</a></li>
<li class="chapter" data-level="4.6" data-path="behavior.html"><a href="behavior.html#removal-model"><i class="fa fa-check"></i><b>4.6</b> Removal model</a><ul>
<li class="chapter" data-level="4.6.1" data-path="behavior.html"><a href="behavior.html#real-data"><i class="fa fa-check"></i><b>4.6.1</b> Real data</a></li>
<li class="chapter" data-level="4.6.2" data-path="behavior.html"><a href="behavior.html#time-invariant-conventional-model"><i class="fa fa-check"></i><b>4.6.2</b> Time-invariant conventional model</a></li>
<li class="chapter" data-level="4.6.3" data-path="behavior.html"><a href="behavior.html#time-varying-conventional-removal-model"><i class="fa fa-check"></i><b>4.6.3</b> Time-varying conventional removal model</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="behavior.html"><a href="behavior.html#finite-mixtures"><i class="fa fa-check"></i><b>4.7</b> Finite mixtures</a><ul>
<li class="chapter" data-level="4.7.1" data-path="behavior.html"><a href="behavior.html#time-invariant-finite-mixture-removal-model"><i class="fa fa-check"></i><b>4.7.1</b> Time-invariant finite mixture removal model</a></li>
<li class="chapter" data-level="4.7.2" data-path="behavior.html"><a href="behavior.html#time-varying-finite-mixture-removal-models"><i class="fa fa-check"></i><b>4.7.2</b> Time-varying finite mixture removal models</a></li>
</ul></li>
<li class="chapter" data-level="4.8" data-path="behavior.html"><a href="behavior.html#let-the-best-model-win"><i class="fa fa-check"></i><b>4.8</b> Let the best model win</a></li>
<li class="chapter" data-level="4.9" data-path="behavior.html"><a href="behavior.html#exercises"><i class="fa fa-check"></i><b>4.9</b> Exercises</a></li>
<li class="chapter" data-level="4.10" data-path="behavior.html"><a href="behavior.html#estimating-abundance"><i class="fa fa-check"></i><b>4.10</b> Estimating abundance</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="detection.html"><a href="detection.html"><i class="fa fa-check"></i><b>5</b> The Detection Process</a></li>
<li class="chapter" data-level="6" data-path="recordings.html"><a href="recordings.html"><i class="fa fa-check"></i><b>6</b> Dealing with Recordings</a></li>
<li class="chapter" data-level="7" data-path="assumptions.html"><a href="assumptions.html"><i class="fa fa-check"></i><b>7</b> A Closer Look at Assumptions</a></li>
<li class="chapter" data-level="8" data-path="roadsides.html"><a href="roadsides.html"><i class="fa fa-check"></i><b>8</b> Understanding Roadside Surveys</a></li>
<li class="chapter" data-level="9" data-path="extras.html"><a href="extras.html"><i class="fa fa-check"></i><b>9</b> Miscellaneous Topics</a><ul>
<li class="chapter" data-level="" data-path="extras.html"><a href="extras.html#these-are-just-reminders-to-be-deleted-later"><i class="fa fa-check"></i>These are just reminders, to be deleted later</a></li>
<li class="chapter" data-level="9.1" data-path="extras.html"><a href="extras.html#binomial-model-and-censoring"><i class="fa fa-check"></i><b>9.1</b> Binomial model and censoring</a><ul>
<li class="chapter" data-level="9.1.1" data-path="extras.html"><a href="extras.html#optimal-partitioning"><i class="fa fa-check"></i><b>9.1.1</b> Optimal partitioning</a></li>
<li class="chapter" data-level="9.1.2" data-path="extras.html"><a href="extras.html#optilevels"><i class="fa fa-check"></i><b>9.1.2</b> Optilevels</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="http://peter.solymos.org/" target="blank">P&eacute;ter S&oacute;lymos</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Point count data analysis: How to violate assumptions and get away with it</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="behavior" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> Behavioral Complexities</h1>
<div id="introduction-2" class="section level2">
<h2><span class="header-section-number">4.1</span> Introduction</h2>
<p>We have reviewed so far how to fit <em>naive</em> models to estimate
the expected value of the observed counts, <span class="math inline">\(\lambda\)</span>.
So what is this <span class="math inline">\(\lambda\)</span>?
Here are some deifinitions for further discussion:</p>
<ul>
<li><strong>relative abundance</strong>: <span class="math inline">\(\lambda\)</span> without any reference to nuisance variables, but possibly standardized by design, or nuisance variables used as fixed effects,</li>
<li><strong>abundance</strong>: <span class="math inline">\(N=\lambda/C\)</span>, <span class="math inline">\(C\)</span> is a correction factor and <span class="math inline">\(N\)</span> refers to the number of individuals within the area surveyed – the problem is that we cannot measure this directly (this is a latent variable), moreover the survey area is also often unknown (i.e. for unlimited distance counts),</li>
<li><strong>occupancy</strong>: the probability that the survey area is occupied, this is really equivalent to the indicator function <span class="math inline">\(N&gt;0\)</span>,</li>
<li><strong>density</strong> <span class="math inline">\(D = N/A = \lambda/AC\)</span>, abundance per unit area – same problems as above: both <span class="math inline">\(N\)</span> and <span class="math inline">\(A\)</span> are unknowns.</li>
</ul>
<p>Our objective in the following chapters is to work out the details of
estimating abundance and density in some clever ways through
learning about the nature of the mechanisms contributing to <span class="math inline">\(C\)</span>.</p>
</div>
<div id="prerequisites-2" class="section level2">
<h2><span class="header-section-number">4.2</span> Prerequisites</h2>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bSims)                <span class="co"># simulations</span>
<span class="kw">library</span>(detect)               <span class="co"># multinomial models</span>
<span class="kw">source</span>(<span class="st">&quot;functions.R&quot;</span>)         <span class="co"># some useful stuff</span>
<span class="kw">load</span>(<span class="st">&quot;_data/josm/josm.rda&quot;</span>) <span class="co"># JOSM data</span></code></pre>
</div>
<div id="birds-in-the-forest" class="section level2">
<h2><span class="header-section-number">4.3</span> Birds in the forest</h2>
<p>Build a landscape: extent is given in 100 m units</p>
<pre class="sourceCode r"><code class="sourceCode r">(l &lt;-<span class="st"> </span><span class="kw">bsims_init</span>(<span class="dt">extent=</span><span class="dv">10</span>))</code></pre>
<pre><code>## bSims landscape
##   1 km x 1 km
##   stratification: H</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(l)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-198-1.png" width="288" /></p>
<p>We have a 100 ha landscape that we populate with birds,
1 bird / ha using a Poisson spatial point process.
As a result, we have <span class="math inline">\(N\)</span> birds in the landscape,
<span class="math inline">\(N \sim Poisson(\lambda)\)</span>, <span class="math inline">\(\lambda = DA\)</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
(a &lt;-<span class="st"> </span><span class="kw">bsims_populate</span>(l, <span class="dt">density=</span><span class="fl">0.5</span>))</code></pre>
<pre><code>## bSims population
##   1 km x 1 km
##   stratification: H
##   total abundance: 52</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(a)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-200-1.png" width="288" /></p>
<p>The locations can be seen as nest locations (<code>a$nests</code> stores the locations).
But birds don’t just stay put in one place. They move and vocalize:</p>
<pre class="sourceCode r"><code class="sourceCode r">(b &lt;-<span class="st"> </span><span class="kw">bsims_animate</span>(a, 
  <span class="dt">vocal_rate=</span><span class="fl">0.5</span>, <span class="dt">duration=</span><span class="dv">10</span>,
  <span class="dt">move_rate=</span><span class="dv">1</span>, <span class="dt">movement=</span><span class="fl">0.25</span>))</code></pre>
<pre><code>## bSims events
##   1 km x 1 km
##   stratification: H
##   total abundance: 52
##   total duration: 10</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(b)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-202-1.png" width="288" /></p>
<p>The <code>get_events</code> function, as the name implies, extracts the events:
movements (<code>$v</code> is 0) and vocalizations (<code>$v</code> is 1) alike,
unless filtered for vocalization events only.
Besides the coordinates, we also have the time of event (<code>$t</code>) and
the individual identifier (<code>$i</code> linking to the rows of the <code>b$nests</code> table):</p>
<pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">get_events</span>(b, <span class="dt">vocal_only=</span><span class="ot">FALSE</span>)
<span class="kw">head</span>(e)
v &lt;-<span class="st"> </span><span class="kw">get_events</span>(b, <span class="dt">vocal_only=</span><span class="ot">TRUE</span>)
<span class="kw">head</span>(v)</code></pre>
</div>
<div id="survival-model" class="section level2">
<h2><span class="header-section-number">4.4</span> Survival model</h2>
<p>Survival models assess time-to-event data which is often censored
(some event has not occurred at the time the data collection ended).</p>
<p>Event time (<span class="math inline">\(T\)</span>) is a continuous random variable.
In the simplest case, its probability density function is the Exponential
distribution: <span class="math inline">\(f(t)=\phi e^{-t\phi}\)</span>.
The corresponding cumulative distribution function is:
<span class="math inline">\(F(t)=\int_{0}^{t} f(t)dt=1-e^{-t\phi}\)</span>,
giving the probability that the event has occurred by duration <span class="math inline">\(t\)</span> and we will refer to
this probability as <span class="math inline">\(p_t\)</span>. The parameter <span class="math inline">\(\phi\)</span> is the rate of the Exponential distribution
with mean <span class="math inline">\(1/\phi\)</span> and variance <span class="math inline">\(1/\phi^2\)</span>.</p>
<p>In survival model, the complement of <span class="math inline">\(F(t)\)</span> is called the
<em>survival function</em> (<span class="math inline">\(S(t)=1-F(t)\)</span>, <span class="math inline">\(S(0)=1\)</span>),
which gives the probability that the event has not occurred by duration <span class="math inline">\(t\)</span>.
The the <em>hazard function</em> (<span class="math inline">\(\lambda(t)=f(t)/S(t)\)</span>)
which defines the instantaneous rate of occurrence of the event
(the density of events at <span class="math inline">\(t\)</span> divided by the probability of surviving).
The cumulative hazard (cumulative risk) the sum of the risks between doration 0 and <span class="math inline">\(t\)</span>
(<span class="math inline">\(\Lambda(t)=\int_{0}^{t} \lambda(t)dt\)</span>).</p>
<p>The simplest survival distribution assumes constant risk over time (<span class="math inline">\(\lambda(t)=\phi\)</span>),
which corresponds to the Exponential distribution.
The Exponential distribution also happens to describe the lengths of the
inter-event times in a homogeneous Poisson process (events are independent, ‘memory-less’ process).</p>
</div>
<div id="vocalization-events" class="section level2">
<h2><span class="header-section-number">4.5</span> Vocalization events</h2>
<p>Event times in our bSims example follow a Poisson process with rate <span class="math inline">\(\phi\)</span> (<code>vocal_rate</code>)
within <code>duration</code> <span class="math inline">\(t=10\)</span> minutes.</p>
<p>Let’s subset the vocalization events to include the time of first detections
for each individual (<code>v1</code>). The estimated rate should match our setting,
the plot shows the Exponential probability density function on top of
the event times:</p>
<pre class="sourceCode r"><code class="sourceCode r">v1 &lt;-<span class="st"> </span>v[<span class="op">!</span><span class="kw">duplicated</span>(v<span class="op">$</span>i),]

tmp &lt;-<span class="st"> </span>v1
tmp<span class="op">$</span>o &lt;-<span class="st"> </span><span class="kw">seq_len</span>(<span class="kw">nrow</span>(v1))
<span class="kw">plot</span>(o <span class="op">~</span><span class="st"> </span>t, tmp, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Individuals&quot;</span>,
  <span class="dt">main=</span><span class="st">&quot;Vocalization events&quot;</span>, 
  <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(b<span class="op">$</span>nests)), <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">10</span>))
<span class="cf">for</span> (i <span class="cf">in</span> tmp<span class="op">$</span>o) {
  tmp2 &lt;-<span class="st"> </span>v[v<span class="op">$</span>i <span class="op">==</span><span class="st"> </span>v1<span class="op">$</span>i[i],]
  <span class="kw">lines</span>(<span class="kw">c</span>(tmp2<span class="op">$</span>t[<span class="dv">1</span>], <span class="dv">10</span>), <span class="kw">c</span>(i,i), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)
  <span class="kw">points</span>(tmp2<span class="op">$</span>t, <span class="kw">rep</span>(i, <span class="kw">nrow</span>(tmp2)), <span class="dt">cex=</span><span class="fl">0.5</span>)
  <span class="kw">points</span>(tmp2<span class="op">$</span>t[<span class="dv">1</span>], i, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">cex=</span><span class="fl">0.5</span>)
}</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-204-1.png" width="672" /></p>
<pre class="sourceCode r"><code class="sourceCode r">(phi &lt;-<span class="st"> </span>b<span class="op">$</span>vocal_rate[<span class="dv">1</span>])</code></pre>
<pre><code>## [1] 0.5</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(phi_hat &lt;-<span class="st"> </span><span class="kw">fitdistr</span>(v1<span class="op">$</span>t, <span class="st">&quot;exponential&quot;</span>)<span class="op">$</span>estimate)</code></pre>
<pre><code>##   rate 
## 0.4808</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(v1<span class="op">$</span>t, <span class="dt">xlab=</span><span class="st">&quot;Time of first detection (min)&quot;</span>, <span class="dt">freq=</span><span class="ot">FALSE</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>, 
  <span class="dt">col=</span><span class="st">&quot;lightgrey&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;f(t)&quot;</span>)
<span class="kw">curve</span>(<span class="kw">dexp</span>(x, phi), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">2</span>)
<span class="kw">curve</span>(<span class="kw">dexp</span>(x, phi_hat), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="dt">bty=</span><span class="st">&quot;n&quot;</span>, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">col=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>), 
  <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;Expected&quot;</span>, <span class="st">&quot;Estimated&quot;</span>))</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-205-1.png" width="672" /></p>
<p>Now let’s visualize the corresponding cumulative distribution function.
We also bin the events into time intervals defined by interval end times
in the vector <code>br</code> (breaks to be used with <code>cut</code>):</p>
<pre class="sourceCode r"><code class="sourceCode r">br &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">10</span>)
i &lt;-<span class="st"> </span><span class="kw">cut</span>(v1<span class="op">$</span>t, <span class="kw">c</span>(<span class="dv">0</span>, br), <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>)
<span class="kw">table</span>(i)</code></pre>
<pre><code>## i
##  [0,3]  (3,5] (5,10] 
##     38     11      3</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">stepfun</span>(v1<span class="op">$</span>t, (<span class="dv">0</span><span class="op">:</span><span class="kw">nrow</span>(v1))<span class="op">/</span><span class="kw">nrow</span>(v1)), <span class="dt">do.points=</span><span class="ot">FALSE</span>, <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">10</span>),
  <span class="dt">xlab=</span><span class="st">&quot;Time of first detection (min)&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;F(t)&quot;</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>)
<span class="kw">curve</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span>phi<span class="op">*</span>x), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">2</span>)
<span class="kw">curve</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span>phi_hat<span class="op">*</span>x), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">legend</span>(<span class="st">&quot;bottomright&quot;</span>, <span class="dt">bty=</span><span class="st">&quot;n&quot;</span>, <span class="dt">lty=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="ot">NA</span>), 
  <span class="dt">col=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>), <span class="dt">pch=</span><span class="kw">c</span>(<span class="ot">NA</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,<span class="dv">21</span>),
  <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;Empirical&quot;</span>, <span class="st">&quot;Expected&quot;</span>, <span class="st">&quot;Estimated&quot;</span>, <span class="st">&quot;Binned&quot;</span>))
<span class="kw">points</span>(br, <span class="kw">cumsum</span>(<span class="kw">table</span>(i))<span class="op">/</span><span class="kw">sum</span>(<span class="kw">table</span>(i)), <span class="dt">cex=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="dv">3</span>, <span class="dt">pch=</span><span class="dv">21</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-206-1.png" width="672" /></p>
</div>
<div id="removal-model" class="section level2">
<h2><span class="header-section-number">4.6</span> Removal model</h2>
<p>The time-removal model, originally developed for estimating wildlife and fish abundances from mark-recapture studies, was later reformulated for avian surveys with the goal of improving estimates of bird abundance by accounting for the availability bias inherent in point-count data. The removal model applied to point-count surveys estimates the probability that a bird is available for detection as a function of the average number of detectable cues that an individual bird gives per minute (singing rate, <span class="math inline">\(\phi\)</span>), and the known count duration (<span class="math inline">\(t\)</span>).</p>
<p>Time-removal models are based on a removal experiment whereby animals are trapped and thereby removed from the closed population of animals being sampled. When applying a removal model to avian point-count surveys, the counts of singing birds (<span class="math inline">\(Y_{ij}, \ldots, Y_{iJ}\)</span>) within a given point-count survey <span class="math inline">\(i\)</span> (<span class="math inline">\(i = 1,\ldots, n\)</span>) are tallied relative to when each bird is first detected in multiple and consecutive time intervals, with the survey start time <span class="math inline">\(t_{i0} = 0\)</span>, the end times of the time intervals <span class="math inline">\(t_{ij}\)</span> (<span class="math inline">\(j = 1, 2,\ldots, J\)</span>), and the total count duration of the survey <span class="math display">\[t_{iJ}\]</span>. We count each individual bird once, so individuals are ‘mentally removed’ from a closed population of undetected birds by the surveyor.</p>
<p>The continuous-time formulation of the removal model is identical to the Exponential survival model
formulation with respect to the cumulative density function, which defines probability of
availability for sampling given the occurrence of the species.
The response variable in the removal model follows multinomial distribution
with cell probabilities derived from the cumulative probability function.</p>
<p>We will use the <code>detect::cmulti</code> function to fit multinomial models using
conditional maximum likelihood procedure (the conditioning means that we only use
observations where the total count is not 0, i.e. the species was present).
The <code>Y</code> matrix lists the number of new individuals counted in each time interval,
the <code>D</code> matrix gives the interval end times.
(We use the <code>detect::cmulti.fit</code> function to be able to fit the model to a single survey.)</p>
<pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">as.numeric</span>(<span class="kw">table</span>(i)), <span class="dt">nrow=</span><span class="dv">1</span>))</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]   38   11    3</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(d &lt;-<span class="st"> </span><span class="kw">matrix</span>(br, <span class="dt">nrow=</span><span class="dv">1</span>))</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    3    5   10</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(phi_hat1 &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">cmulti.fit</span>(y, d, <span class="dt">type=</span><span class="st">&quot;rem&quot;</span>)<span class="op">$</span>coef))</code></pre>
<pre><code>## [1] 0.4683</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">phi <span class="co"># setting</span></code></pre>
<pre><code>## [1] 0.5</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">phi_hat <span class="co"># from time-to-event data</span></code></pre>
<pre><code>##   rate 
## 0.4808</code></pre>
<div id="real-data" class="section level3">
<h3><span class="header-section-number">4.6.1</span> Real data</h3>
<p>Let’s pick a species from the JOSM data set.
For predictors, we will use a variable capturing date (<code>DAY</code>; standardized ordinal day of the year)
and an other one capturing time of day (<code>TSSR</code>; time since local sunrise).
The data frame <code>X</code> contains the predictors.
The matrix <code>Y</code> contains the counts of newly counted individuals binned into consecutive time intervals:
cell values are the <span class="math inline">\(Y_{ij}\)</span>’s. The <code>D</code> object is another matrix mirroring the structure of <code>Y</code>
but instead of counts, it contains the interval end times: cell values are
the <span class="math inline">\(t_{ij}\)</span>’s.</p>
<pre class="sourceCode r"><code class="sourceCode r">yall &lt;-<span class="st"> </span><span class="kw">Xtab</span>(<span class="op">~</span><span class="st"> </span>SiteID <span class="op">+</span><span class="st"> </span>Dur <span class="op">+</span><span class="st"> </span>SpeciesID, 
  josm<span class="op">$</span>counts[josm<span class="op">$</span>counts<span class="op">$</span>DetectType1 <span class="op">!=</span><span class="st"> &quot;V&quot;</span>,])

spp &lt;-<span class="st"> &quot;TEWA&quot;</span>

Y &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(yall[[spp]])
D &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">10</span>), <span class="kw">nrow</span>(Y), <span class="dv">3</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>,
  <span class="dt">dimnames=</span><span class="kw">dimnames</span>(Y))
X &lt;-<span class="st"> </span>josm<span class="op">$</span>surveys[<span class="kw">rownames</span>(Y), <span class="kw">c</span>(<span class="st">&quot;DAY&quot;</span>, <span class="st">&quot;TSSR&quot;</span>)]
<span class="kw">head</span>(Y[<span class="kw">rowSums</span>(Y) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>,])</code></pre>
<pre><code>##         0-3min 3-5min 5-10min
## CL10106      4      0       0
## CL10112      2      0       0
## CL10120      1      1       0
## CL10170      1      0       0
## CL10172      0      0       2
## CL10181      0      0       1</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(D)</code></pre>
<pre><code>##         0-3min 3-5min 5-10min
## CL10102      3      5      10
## CL10106      3      5      10
## CL10108      3      5      10
## CL10109      3      5      10
## CL10111      3      5      10
## CL10112      3      5      10</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(X)</code></pre>
<pre><code>##       DAY             TSSR        
##  Min.   :0.392   Min.   :-0.0285  
##  1st Qu.:0.422   1st Qu.: 0.0506  
##  Median :0.452   Median : 0.1041  
##  Mean   :0.450   Mean   : 0.1040  
##  3rd Qu.:0.474   3rd Qu.: 0.1568  
##  Max.   :0.504   Max.   : 0.2357</code></pre>
</div>
<div id="time-invariant-conventional-model" class="section level3">
<h3><span class="header-section-number">4.6.2</span> Time-invariant conventional model</h3>
<p>Time-invariant means that the rate is constant over time
(i.e. no difference between morning and midnight),
while conventional refers to the assumption
that all individuals share the same rate
(their behaviour is identical in this regard).</p>
<p>In the time-invariant conventional removal model (<code>Me0</code>),
the individuals of a species at a given location and time are assumed to be homogeneous
in their singing rates.
The time to first detection follows the Exponential distribution,
and the cumulative density function of times to first detection in time interval
(0, <span class="math inline">\(t_{iJ}\)</span>) gives us the probability that a bird sings at least once during the point count as
<span class="math inline">\(p(t_{iJ}) = 1 - exp(-t_{iJ} \phi)\)</span>.</p>
<p>We fit this model by specifying intercep-only in the
right hand side of the formula, and <code>type=&quot;rem&quot;</code>
as part of the <code>cmulti</code> call:</p>
<pre class="sourceCode r"><code class="sourceCode r">Me0 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">type=</span><span class="st">&quot;rem&quot;</span>)
<span class="kw">summary</span>(Me0)</code></pre>
<pre><code>## 
## Call:
## cmulti(formula = Y | D ~ 1, type = &quot;rem&quot;)
## 
## Removal Sampling (homogeneous singing rate)
## Conditional Maximum Likelihood estimates
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## log.phi_(Intercept)  -0.8547     0.0174   -49.1   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Log-likelihood: -3.2e+03 
## BIC = 6.42e+03</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(phi_Me0 &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">coef</span>(Me0)))</code></pre>
<pre><code>## log.phi_(Intercept) 
##              0.4254</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">curve</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">*</span>phi_Me0), <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">10</span>), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">col=</span><span class="dv">4</span>,
  <span class="dt">xlab=</span><span class="st">&quot;Duration (min)&quot;</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">p</span>(t[J])), 
  <span class="dt">main=</span><span class="kw">paste</span>(spp, <span class="st">&quot;Me0&quot;</span>))
<span class="kw">points</span>(D[<span class="dv">1</span>,], <span class="kw">cumsum</span>(<span class="kw">colSums</span>(Y))<span class="op">/</span><span class="kw">sum</span>(Y), <span class="dt">cex=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="dv">3</span>, <span class="dt">pch=</span><span class="dv">21</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-209-1.png" width="672" /></p>
</div>
<div id="time-varying-conventional-removal-model" class="section level3">
<h3><span class="header-section-number">4.6.3</span> Time-varying conventional removal model</h3>
<p>Singing rates of birds vary with time of day, time of year, breeding status, and stage of the nesting cycle.
Thus, removal model estimates of availability may be improved by accounting for variation in singing rates
using covariates for day of year and time of day.
In this case <span class="math inline">\(p(t_{iJ}) = 1 - e^{-t_{iJ} \phi_{i}}\)</span> and <span class="math inline">\(log(\phi_{i}) = \beta_{0} + \sum^{K}_{k=1} \beta_{k} x_{ik}\)</span> is the linear predictor with <span class="math inline">\(K\)</span> covariates and the corresponding unknown coefficients (<span class="math inline">\(\beta_{k}\)</span>, <span class="math inline">\(k = 0,\ldots, K\)</span>).</p>
<p>Let’s fit a couple of time-varying models using <code>DAY</code> and <code>TSSR</code> as covariates:</p>
<pre class="sourceCode r"><code class="sourceCode r">Me1 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span>DAY, X, <span class="dt">type=</span><span class="st">&quot;rem&quot;</span>)
Me2 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span>TSSR, X, <span class="dt">type=</span><span class="st">&quot;rem&quot;</span>)</code></pre>
<p>Now compare the three conventional models based on AIC and inspect the summary for the best supported model with the <code>JDAY</code> effect.</p>
<pre class="sourceCode r"><code class="sourceCode r">Me_AIC &lt;-<span class="st"> </span><span class="kw">AIC</span>(Me0, Me1, Me2)
Me_AIC<span class="op">$</span>delta_AIC &lt;-<span class="st"> </span>Me_AIC<span class="op">$</span>AIC <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(Me_AIC<span class="op">$</span>AIC)
Me_AIC[<span class="kw">order</span>(Me_AIC<span class="op">$</span>AIC),]

Me_Best &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="kw">rownames</span>(Me_AIC)[Me_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>])
<span class="kw">summary</span>(Me_Best)</code></pre>
<pre><code>## 
## Call:
## cmulti(formula = Y | D ~ DAY, data = X, type = &quot;rem&quot;)
## 
## Removal Sampling (homogeneous singing rate)
## Conditional Maximum Likelihood estimates
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## log.phi_(Intercept)   0.0784     0.2615    0.30  0.76427    
## log.phi_DAY          -2.0910     0.5866   -3.56  0.00036 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Log-likelihood: -3.2e+03 
## BIC = 6.41e+03</code></pre>
<p>To visually capture the time-varying effects, we make some plots using base graphics,
colors matching the time-varying predictor. This way we can not only assess how availability
probability (given a fixed time interval) is changing with the values of the predictor,
but also how the cumulative distribution changes with time.</p>
<pre class="sourceCode r"><code class="sourceCode r">b &lt;-<span class="st"> </span><span class="kw">coef</span>(Me_Best)

n &lt;-<span class="st"> </span><span class="dv">100</span>
DAY &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(X<span class="op">$</span>DAY), <span class="kw">max</span>(X<span class="op">$</span>DAY), <span class="dt">length.out=</span>n<span class="op">+</span><span class="dv">1</span>)
TSSR &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(X<span class="op">$</span>TSSR), <span class="kw">max</span>(X<span class="op">$</span>TSSR), <span class="dt">length.out=</span>n<span class="op">+</span><span class="dv">1</span>)
Duration &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dt">length.out=</span>n)
col &lt;-<span class="st"> </span><span class="kw">colorRampPalette</span>(<span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;yellow&quot;</span>, <span class="st">&quot;blue&quot;</span>))(n)

op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
p1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span><span class="dv">3</span><span class="op">*</span><span class="kw">exp</span>(b[<span class="dv">1</span>]<span class="op">+</span>b[<span class="dv">2</span>]<span class="op">*</span>DAY))
<span class="kw">plot</span>(DAY, p1, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">type=</span><span class="st">&quot;n&quot;</span>,
    <span class="dt">main=</span><span class="kw">paste</span>(spp, <span class="kw">rownames</span>(Me_AIC)[Me_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>]),
    <span class="dt">ylab=</span><span class="st">&quot;P(availability)&quot;</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    <span class="kw">lines</span>(DAY[<span class="kw">c</span>(i,i<span class="op">+</span><span class="dv">1</span>)], p1[<span class="kw">c</span>(i,i<span class="op">+</span><span class="dv">1</span>)], <span class="dt">col=</span>col[i], <span class="dt">lwd=</span><span class="dv">2</span>)
}
<span class="kw">abline</span>(<span class="dt">h=</span><span class="kw">range</span>(p1), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)

<span class="kw">plot</span>(Duration, Duration, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),
    <span class="dt">ylab=</span><span class="st">&quot;P(availability)&quot;</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    p2 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span>Duration<span class="op">*</span><span class="kw">exp</span>(b[<span class="dv">1</span>]<span class="op">+</span>b[<span class="dv">2</span>]<span class="op">*</span>DAY[i]))
    <span class="kw">lines</span>(Duration, p2, <span class="dt">col=</span>col[i])
}
<span class="kw">abline</span>(<span class="dt">v=</span><span class="dv">3</span>, <span class="dt">h=</span><span class="kw">range</span>(p1), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-211-1.png" width="672" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(op)</code></pre>
</div>
</div>
<div id="finite-mixtures" class="section level2">
<h2><span class="header-section-number">4.7</span> Finite mixtures</h2>
<p>Let’s relax the assumption that all individuals vocalize at the same rate.
We can think about this as different groups in the population.
The individuals within the groups have homogenerous rates,
but the group level rates are different.
We can introduce such heterogeneity into our bSims world by
specifying the group level rates (<code>phi</code> vector) and the
proportion of individuals belonging to the groups (<code>mix</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r">phi &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>, <span class="fl">0.5</span>)
mix &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.25</span>, <span class="fl">0.75</span>)

<span class="kw">set.seed</span>(<span class="dv">1</span>)
(a2 &lt;-<span class="st"> </span><span class="kw">bsims_populate</span>(l, <span class="dt">density=</span><span class="dv">1</span>)) <span class="co"># increase density</span></code></pre>
<pre><code>## bSims population
##   1 km x 1 km
##   stratification: H
##   total abundance: 104</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(b2 &lt;-<span class="st"> </span><span class="kw">bsims_animate</span>(a2, <span class="dt">vocal_rate=</span>phi, <span class="dt">mixture=</span>mix))</code></pre>
<pre><code>## bSims events
##   1 km x 1 km
##   stratification: H
##   total abundance: 104
##   mixture with total duration: 10</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">b2<span class="op">$</span>vocal_rate</code></pre>
<pre><code>##   G1  G2
## H 10 0.5
## E 10 0.5
## R 10 0.5</code></pre>
<p>If we plot the time to first detection data, we can see how
expected distribution (red) is different from the fitted
Exponential distribution assuming homogeneity:</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">get_events</span>(b2, <span class="dt">vocal_only=</span><span class="ot">TRUE</span>)
v1 &lt;-<span class="st"> </span>v[<span class="op">!</span><span class="kw">duplicated</span>(v<span class="op">$</span>i),]
(phi_hat &lt;-<span class="st"> </span><span class="kw">fitdistr</span>(v1<span class="op">$</span>t, <span class="st">&quot;exponential&quot;</span>)<span class="op">$</span>estimate)</code></pre>
<pre><code>##   rate 
## 0.6522</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(v1<span class="op">$</span>t, <span class="dt">xlab=</span><span class="st">&quot;Time of first detection (min)&quot;</span>, <span class="dt">freq=</span><span class="ot">FALSE</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>, 
  <span class="dt">col=</span><span class="st">&quot;lightgrey&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;f(t)&quot;</span>)
<span class="kw">curve</span>(mix[<span class="dv">1</span>]<span class="op">*</span><span class="kw">dexp</span>(x, phi[<span class="dv">1</span>])<span class="op">+</span>mix[<span class="dv">2</span>]<span class="op">*</span><span class="kw">dexp</span>(x, phi[<span class="dv">2</span>]), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">2</span>)
<span class="kw">curve</span>(<span class="kw">dexp</span>(x, phi_hat), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="dt">bty=</span><span class="st">&quot;n&quot;</span>, <span class="dt">lty=</span><span class="dv">1</span>, <span class="dt">col=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>), 
  <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;Expected (mixture)&quot;</span>, <span class="st">&quot;Estimated (exponential)&quot;</span>))</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-213-1.png" width="672" /></p>
<p>Now let’s visualize the corresponding cumulative distribution function:</p>
<pre class="sourceCode r"><code class="sourceCode r">br &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
i &lt;-<span class="st"> </span><span class="kw">cut</span>(v1<span class="op">$</span>t, <span class="kw">c</span>(<span class="dv">0</span>, br), <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>)
<span class="kw">table</span>(i)</code></pre>
<pre><code>## i
##  [0,1]  (1,2]  (2,3]  (3,4]  (4,5]  (5,6]  (6,7]  (7,8]  (8,9] (9,10] 
##     54     23     10      6      2      6      3      0      0      0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">stepfun</span>(v1<span class="op">$</span>t, (<span class="dv">0</span><span class="op">:</span><span class="kw">nrow</span>(v1))<span class="op">/</span><span class="kw">nrow</span>(v1)), <span class="dt">do.points=</span><span class="ot">FALSE</span>, <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">10</span>),
  <span class="dt">xlab=</span><span class="st">&quot;Time of first detection (min)&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;F(t)&quot;</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>)
<span class="kw">curve</span>(<span class="dv">1</span><span class="op">-</span>mix[<span class="dv">2</span>]<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>phi[<span class="dv">2</span>]<span class="op">*</span>x), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">2</span>)
<span class="kw">curve</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span>phi_hat<span class="op">*</span>x), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">legend</span>(<span class="st">&quot;bottomright&quot;</span>, <span class="dt">bty=</span><span class="st">&quot;n&quot;</span>, <span class="dt">lty=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="ot">NA</span>), 
  <span class="dt">col=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>), <span class="dt">pch=</span><span class="kw">c</span>(<span class="ot">NA</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,<span class="dv">21</span>),
  <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;Empirical&quot;</span>, <span class="st">&quot;Expected (mixture)&quot;</span>, <span class="st">&quot;Estimated (exponential)&quot;</span>, <span class="st">&quot;Binned&quot;</span>))
<span class="kw">points</span>(br, <span class="kw">cumsum</span>(<span class="kw">table</span>(i))<span class="op">/</span><span class="kw">sum</span>(<span class="kw">table</span>(i)), <span class="dt">cex=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="dv">3</span>, <span class="dt">pch=</span><span class="dv">21</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-214-1.png" width="672" /></p>
<p>We use the <code>detect::cmulti</code> function to fit the finite mixture model:</p>
<pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">as.numeric</span>(<span class="kw">table</span>(i)), <span class="dt">nrow=</span><span class="dv">1</span>))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]   54   23   10    6    2    6    3    0    0     0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(d &lt;-<span class="st"> </span><span class="kw">matrix</span>(br, <span class="dt">nrow=</span><span class="dv">1</span>))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    1    2    3    4    5    6    7    8    9    10</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">cf &lt;-<span class="st"> </span><span class="kw">cmulti.fit</span>(y, d, <span class="dt">type=</span><span class="st">&quot;fmix&quot;</span>)<span class="op">$</span>coef <span class="co"># log.phi, logit.c</span>

<span class="kw">c</span>(<span class="dt">phi=</span>phi[<span class="dv">2</span>], <span class="dt">c=</span>mix[<span class="dv">2</span>]) <span class="co"># setting</span></code></pre>
<pre><code>##  phi    c 
## 0.50 0.75</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="dt">phi_hat=</span><span class="kw">exp</span>(cf[<span class="dv">1</span>]), <span class="dt">c_hat=</span><span class="kw">plogis</span>(cf[<span class="dv">2</span>])) <span class="co"># estimate</span></code></pre>
<pre><code>## phi_hat   c_hat 
##  0.5350  0.8244</code></pre>
<div id="time-invariant-finite-mixture-removal-model" class="section level3">
<h3><span class="header-section-number">4.7.1</span> Time-invariant finite mixture removal model</h3>
<p>The removal model can accommodate behavioral heterogeneity in singing by subdividing the
sampled population for a species at a given point into a finite mixture of birds with low and
high singing rates, which requires the additional estimation of the proportion of birds in the
sampled population with low singing rates.</p>
<p>In the continuous-time formulation of the finite mixture (or two-point mixture) removal model,
the cumulative density function during a point count is given by
<span class="math inline">\(p(t_{iJ}) = (1 - c) 1 + c (1 - e^{-t_{iJ} \phi}) = 1 - c e^{-t_{iJ} \phi}\)</span>, where
<span class="math inline">\(\phi\)</span> is the singing rate for the group of infrequently singing birds, and <span class="math inline">\(c\)</span> is the
proportion of birds during the point count that are infrequent singers. The remaining
proportions (<span class="math inline">\(1 - c\)</span>; the intercept of the cumulative density function) of the frequent
singers are assumed to be detected instantaneously at the start of the first time interval.
In the simplest form of the finite mixture model, the proportion and singing rate of birds
that sing infrequently is homogeneous across all times and locations (model <code>Mf0</code>).
We are using the <code>type = &quot;fmix&quot;</code> for finite mixture removal models.</p>
<p>Here, for the read bird data set:</p>
<pre class="sourceCode r"><code class="sourceCode r">Mf0 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">type=</span><span class="st">&quot;fmix&quot;</span>)
<span class="kw">summary</span>(Mf0)</code></pre>
<pre><code>## 
## Call:
## cmulti(formula = Y | D ~ 1, type = &quot;fmix&quot;)
## 
## Removal Sampling (heterogeneous singing rate)
## Conditional Maximum Likelihood estimates
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## log.phi_(Intercept)  -1.7146     0.0970  -17.68   &lt;2e-16 ***
## logit.c               0.0742     0.0598    1.24     0.21    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Log-likelihood: -3.1e+03 
## BIC = 6.22e+03</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">cf_Mf0 &lt;-<span class="st"> </span><span class="kw">coef</span>(Mf0)

<span class="kw">curve</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">plogis</span>(cf_Mf0[<span class="dv">2</span>]) <span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">*</span><span class="kw">exp</span>(cf_Mf0[<span class="dv">1</span>])), 
  <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">10</span>), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">main=</span><span class="kw">paste</span>(spp, <span class="st">&quot;Mf0&quot;</span>),
  <span class="dt">xlab=</span><span class="st">&quot;Duration (min)&quot;</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">p</span>(t[J])))
<span class="kw">points</span>(D[<span class="dv">1</span>,], <span class="kw">cumsum</span>(<span class="kw">colSums</span>(Y))<span class="op">/</span><span class="kw">sum</span>(Y), <span class="dt">cex=</span><span class="dv">2</span>, <span class="dt">col=</span><span class="dv">3</span>, <span class="dt">pch=</span><span class="dv">21</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-216-1.png" width="672" /></p>
</div>
<div id="time-varying-finite-mixture-removal-models" class="section level3">
<h3><span class="header-section-number">4.7.2</span> Time-varying finite mixture removal models</h3>
<p>Previously, researchers have applied covariate effects on the parameter
<span class="math inline">\(\phi_{i}\)</span> of the finite mixture model, similarly to how we modeled these effects in conventional models.
This model assumes that the parameter <span class="math inline">\(c\)</span> is constant irrespective of time and location
(i.e. only the infrequent singer group changes its singing behavior).</p>
<p>We can fit finite mixture models with <code>DAY</code> and <code>TSSR</code> as covariates on <span class="math inline">\(\phi\)</span>.
In this case <span class="math inline">\(p(t_{iJ}) = 1 - c e^{-t_{iJ} \phi_{i}}\)</span> and
<span class="math inline">\(log(\phi_{i}) = \beta_{0} + \sum^{K}_{k=1} \beta_{k} x_{ik}\)</span>
is the linear predictor with <span class="math inline">\(K\)</span> covariates and the corresponding unknown coefficients
(<span class="math inline">\(\beta_{k}\)</span>, <span class="math inline">\(k = 0,\ldots, K\)</span>).</p>
<pre class="sourceCode r"><code class="sourceCode r">Mf1 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span>DAY, X, <span class="dt">type=</span><span class="st">&quot;fmix&quot;</span>)
Mf2 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span>TSSR, X, <span class="dt">type=</span><span class="st">&quot;fmix&quot;</span>)</code></pre>
<p>Compare the three finite mixture models based on AIC and inspect the summary for the best supported
model:</p>
<pre class="sourceCode r"><code class="sourceCode r">Mf_AIC &lt;-<span class="st"> </span><span class="kw">AIC</span>(Mf0, Mf1, Mf2)
Mf_AIC<span class="op">$</span>delta_AIC &lt;-<span class="st"> </span>Mf_AIC<span class="op">$</span>AIC <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(Mf_AIC<span class="op">$</span>AIC)

Mf_Best &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="kw">rownames</span>(Mf_AIC)[Mf_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>])
Mf_AIC[<span class="kw">order</span>(Mf_AIC<span class="op">$</span>AIC),]

<span class="kw">summary</span>(Mf_Best)</code></pre>
<pre><code>## 
## Call:
## cmulti(formula = Y | D ~ DAY, data = X, type = &quot;fmix&quot;)
## 
## Removal Sampling (heterogeneous singing rate)
## Conditional Maximum Likelihood estimates
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)   
## log.phi_(Intercept)    0.754      0.848    0.89   0.3739   
## log.phi_DAY           -5.412      1.938   -2.79   0.0052 **
## logit.c                0.119      0.062    1.92   0.0548 . 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Log-likelihood: -3.1e+03 
## BIC = 6.22e+03</code></pre>
<p>We produce a similar plot as before.</p>
<pre class="sourceCode r"><code class="sourceCode r">b &lt;-<span class="st"> </span><span class="kw">coef</span>(Mf_Best)

op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
p1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">plogis</span>(b[<span class="dv">3</span>])<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span><span class="dv">3</span><span class="op">*</span><span class="kw">exp</span>(b[<span class="dv">1</span>]<span class="op">+</span>b[<span class="dv">2</span>]<span class="op">*</span>DAY))
<span class="kw">plot</span>(DAY, p1, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">type=</span><span class="st">&quot;n&quot;</span>,
    <span class="dt">main=</span><span class="kw">paste</span>(spp, <span class="kw">rownames</span>(Mf_AIC)[Mf_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>]),
    <span class="dt">ylab=</span><span class="st">&quot;P(availability)&quot;</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    <span class="kw">lines</span>(DAY[<span class="kw">c</span>(i,i<span class="op">+</span><span class="dv">1</span>)], p1[<span class="kw">c</span>(i,i<span class="op">+</span><span class="dv">1</span>)], <span class="dt">col=</span>col[i], <span class="dt">lwd=</span><span class="dv">2</span>)
}
<span class="kw">abline</span>(<span class="dt">h=</span><span class="kw">range</span>(p1), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)

<span class="kw">plot</span>(Duration, Duration, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),
    <span class="dt">ylab=</span><span class="st">&quot;P(availability)&quot;</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    p2 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">plogis</span>(b[<span class="dv">3</span>])<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>Duration<span class="op">*</span><span class="kw">exp</span>(b[<span class="dv">1</span>]<span class="op">+</span>b[<span class="dv">2</span>]<span class="op">*</span>DAY[i]))
    <span class="kw">lines</span>(Duration, p2, <span class="dt">col=</span>col[i])
}
<span class="kw">abline</span>(<span class="dt">v=</span><span class="dv">3</span>, <span class="dt">h=</span><span class="kw">range</span>(p1), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-219-1.png" width="672" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(op)</code></pre>
<p>An alternative parametrization is that <span class="math inline">\(c_{i}\)</span> rather than <span class="math inline">\(\phi\)</span> be the time-varying parameter,
allowing the individuals to switch between the frequent and infrequent group depending on covariates.
We can fit this class of finite mixture model with <code>DAY</code> and <code>TSSR</code> as covariates on <span class="math inline">\(c\)</span>
using <code>type = &quot;mix&quot;</code> (instead of <code>&quot;fmix&quot;</code>).
In this case <span class="math inline">\(p(t_{iJ}) = 1 - c_{i} e^{-t_{iJ} \phi}\)</span> and
<span class="math inline">\(logit(c_{i}) = \beta_{0} + \sum^{K}_{k=1} \beta_{k} x_{ik}\)</span> is the linear predictor with <span class="math inline">\(K\)</span>
covariates and the corresponding unknown coefficients (<span class="math inline">\(\beta_{k}\)</span>, <span class="math inline">\(k = 0,\ldots, K\)</span>).
Because <span class="math inline">\(c_{i}\)</span> is a proportion, we model it on the logit scale.</p>
<pre class="sourceCode r"><code class="sourceCode r">Mm1 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span>DAY, X, <span class="dt">type=</span><span class="st">&quot;mix&quot;</span>)
Mm2 &lt;-<span class="st"> </span><span class="kw">cmulti</span>(Y <span class="op">|</span><span class="st"> </span>D <span class="op">~</span><span class="st"> </span>TSSR, X, <span class="dt">type=</span><span class="st">&quot;mix&quot;</span>)</code></pre>
<p>We did not fit a null model for this parametrization, because it is identical to the <code>Mf0</code> model,
so that model <code>Mf0</code> is what we use to compare AIC values and inspect the summary for the best
supported model:</p>
<pre class="sourceCode r"><code class="sourceCode r">Mm_AIC &lt;-<span class="st"> </span><span class="kw">AIC</span>(Mf0, Mm1, Mm2)
Mm_AIC<span class="op">$</span>delta_AIC &lt;-<span class="st"> </span>Mm_AIC<span class="op">$</span>AIC <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(Mm_AIC<span class="op">$</span>AIC)

Mm_Best &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="kw">rownames</span>(Mm_AIC)[Mm_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>])
Mm_AIC[<span class="kw">order</span>(Mm_AIC<span class="op">$</span>AIC),]

<span class="kw">summary</span>(Mm_Best)</code></pre>
<pre><code>## 
## Call:
## cmulti(formula = Y | D ~ DAY, data = X, type = &quot;mix&quot;)
## 
## Removal Sampling (heterogeneous singing rate)
## Conditional Maximum Likelihood estimates
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## log.phi               -1.716      0.097  -17.69   &lt;2e-16 ***
## logit.c_(Intercept)   -2.070      0.692   -2.99   0.0028 ** 
## logit.c_DAY            4.804      1.558    3.08   0.0020 ** 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Log-likelihood: -3.1e+03 
## BIC = 6.22e+03</code></pre>
<p>We produce a similar plot as before:</p>
<pre class="sourceCode r"><code class="sourceCode r">b &lt;-<span class="st"> </span><span class="kw">coef</span>(Mm_Best)

op &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
p1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">plogis</span>(b[<span class="dv">2</span>]<span class="op">+</span>b[<span class="dv">3</span>]<span class="op">*</span>DAY)<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span><span class="dv">3</span><span class="op">*</span><span class="kw">exp</span>(b[<span class="dv">1</span>]))
<span class="kw">plot</span>(DAY, p1, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">type=</span><span class="st">&quot;n&quot;</span>,
    <span class="dt">main=</span><span class="kw">paste</span>(spp, <span class="kw">rownames</span>(Mm_AIC)[Mm_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>]),
    <span class="dt">ylab=</span><span class="st">&quot;P(availability)&quot;</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    <span class="kw">lines</span>(DAY[<span class="kw">c</span>(i,i<span class="op">+</span><span class="dv">1</span>)], p1[<span class="kw">c</span>(i,i<span class="op">+</span><span class="dv">1</span>)], <span class="dt">col=</span>col[i], <span class="dt">lwd=</span><span class="dv">2</span>)
}
<span class="kw">abline</span>(<span class="dt">h=</span><span class="kw">range</span>(p1), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)

<span class="kw">plot</span>(Duration, Duration, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),
    <span class="dt">ylab=</span><span class="st">&quot;P(availability)&quot;</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    p2 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">plogis</span>(b[<span class="dv">2</span>]<span class="op">+</span>b[<span class="dv">3</span>]<span class="op">*</span>DAY[i])<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>Duration<span class="op">*</span><span class="kw">exp</span>(b[<span class="dv">1</span>]))
    <span class="kw">lines</span>(Duration, p2, <span class="dt">col=</span>col[i])
}
<span class="kw">abline</span>(<span class="dt">v=</span><span class="dv">3</span>, <span class="dt">h=</span><span class="kw">range</span>(p1), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-222-1.png" width="672" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(op)</code></pre>
</div>
</div>
<div id="let-the-best-model-win" class="section level2">
<h2><span class="header-section-number">4.8</span> Let the best model win</h2>
<p>So which of the 3 parametrizations proved to be best for our data?
It was the finite mixture with time-varying proportion of infrequent singers.
Second was the other finite mixture model, while the conventional model
was lagging behind.</p>
<pre class="sourceCode r"><code class="sourceCode r">M_AIC &lt;-<span class="st"> </span><span class="kw">AIC</span>(Me_Best, Mf_Best, Mm_Best)
M_AIC<span class="op">$</span>delta_AIC &lt;-<span class="st"> </span>M_AIC<span class="op">$</span>AIC <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(M_AIC<span class="op">$</span>AIC)
M_AIC[<span class="kw">order</span>(M_AIC<span class="op">$</span>AIC),]</code></pre>
<p>Finite mixture models provide some really nice insight into how singing behavior changes over time and, due to more parameters, they provide a better fit and thus minimize bias in population size estimates. But all this improvement comes with a price: sample size requirements (or more precisely, the number of detections required) are really high. To have all the benefits with reduced variance, one needs about 1000 non-zero observations to fit finite mixture models, 20 times more than needed to reliably fit conventional removal models. This is much higher than previously suggested minimum sample sizes.</p>
<p>Our findings also indicate that lengthening the count duration from 3 minutes to 5–10 minutes is an important consideration when designing field surveys to increase the accuracy and precision of population estimates. Well-informed survey design combined with various forms of removal sampling are useful in accounting for availability bias in point counts, thereby improving population estimates, and allowing for better integration of disparate studies at larger spatial scales.</p>
</div>
<div id="exercises" class="section level2">
<h2><span class="header-section-number">4.9</span> Exercises</h2>
<ul>
<li>Compare different duration and intervals</li>
<li>Pick other species with lower singing rates (10 min p &lt; 1)</li>
</ul>
</div>
<div id="estimating-abundance" class="section level2">
<h2><span class="header-section-number">4.10</span> Estimating abundance</h2>
<p>Exponential model, bSims data</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
phi &lt;-<span class="st"> </span><span class="fl">0.5</span>
Den &lt;-<span class="st"> </span><span class="dv">1</span>
l &lt;-<span class="st"> </span><span class="kw">bsims_init</span>()
a &lt;-<span class="st"> </span><span class="kw">bsims_populate</span>(l, <span class="dt">density=</span>Den)
b &lt;-<span class="st"> </span><span class="kw">bsims_animate</span>(a, <span class="dt">vocal_rate=</span>phi, <span class="dt">move_rate=</span><span class="dv">0</span>)

tint &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
(tr &lt;-<span class="st"> </span><span class="kw">bsims_transcribe</span>(b, <span class="dt">tint=</span>tint))</code></pre>
<pre><code>## bSims transcript
##   1 km x 1 km
##   stratification: H
##   total abundance: 104
##   total duration: 10
##   detected: 104 heard
##   1st inds. [0-1, 1-2, 2-3, 3-4, 4-5 min] [0+ m]</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">tr<span class="op">$</span>removal <span class="co"># binned new individuals</span></code></pre>
<pre><code>##     0-1min 1-2min 2-3min 3-4min 4-5min
## 0+m     35     28     16     12      6</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(Y &lt;-<span class="st"> </span><span class="kw">sum</span>(tr<span class="op">$</span>removal)) <span class="co"># detected in 0-3 min</span></code></pre>
<pre><code>## [1] 97</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">fit &lt;-<span class="st"> </span><span class="kw">cmulti.fit</span>(tr<span class="op">$</span>removal, <span class="kw">matrix</span>(tint, <span class="dt">nrow=</span><span class="dv">1</span>), <span class="dt">type=</span><span class="st">&quot;rem&quot;</span>)
<span class="kw">exp</span>(fit<span class="op">$</span>coef)</code></pre>
<pre><code>## [1] 0.4083</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(p &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">-</span><span class="kw">exp</span>(<span class="op">-</span><span class="kw">max</span>(tint)<span class="op">*</span><span class="kw">exp</span>(fit<span class="op">$</span>coef)))</code></pre>
<pre><code>## [1] 0.8702</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Y=NC, N=Y/C=Y/p3</span>
(N &lt;-<span class="st"> </span><span class="kw">sum</span>(a<span class="op">$</span>abundance))</code></pre>
<pre><code>## [1] 104</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">(Nhat &lt;-<span class="st"> </span>Y<span class="op">/</span>p)</code></pre>
<pre><code>## [1] 111.5</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># density is N / A</span>
<span class="kw">sum</span>(a<span class="op">$</span>abundance) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(a<span class="op">$</span>area)</code></pre>
<pre><code>## [1] 1.04</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">Nhat <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(a<span class="op">$</span>area)</code></pre>
<pre><code>## [1] 1.115</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># area is known, q=1</span></code></pre>
<p>Multiple-visit stuff for bSims: the counting of new individuals
resets for each interval (also: needs equal intervals)</p>
<pre class="sourceCode r"><code class="sourceCode r">tr<span class="op">$</span>visits</code></pre>
<pre><code>##     0-1min 1-2min 2-3min 3-4min 4-5min
## 0+m     35     48     44     43     45</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">get_events</span>(b, <span class="dt">vocal_only=</span><span class="ot">TRUE</span>)
v &lt;-<span class="st"> </span>v[v<span class="op">$</span>t <span class="op">&lt;=</span><span class="st"> </span><span class="kw">max</span>(tint),]
v1 &lt;-<span class="st"> </span>v[<span class="op">!</span><span class="kw">duplicated</span>(v<span class="op">$</span>i),]

tmp &lt;-<span class="st"> </span>v1
tmp<span class="op">$</span>o &lt;-<span class="st"> </span><span class="kw">seq_len</span>(<span class="kw">nrow</span>(v1))
<span class="kw">plot</span>(o <span class="op">~</span><span class="st"> </span>t, tmp, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Individuals&quot;</span>,
  <span class="dt">main=</span><span class="st">&quot;Vocalization events&quot;</span>, 
  <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(b<span class="op">$</span>nests)), <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="kw">max</span>(tint)))
<span class="cf">for</span> (i <span class="cf">in</span> tmp<span class="op">$</span>o) {
  tmp2 &lt;-<span class="st"> </span>v[v<span class="op">$</span>i <span class="op">==</span><span class="st"> </span>v1<span class="op">$</span>i[i],]
  <span class="kw">lines</span>(<span class="kw">c</span>(tmp2<span class="op">$</span>t[<span class="dv">1</span>], <span class="kw">max</span>(tint)), <span class="kw">c</span>(i,i), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)
  <span class="kw">points</span>(tmp2<span class="op">$</span>t, <span class="kw">rep</span>(i, <span class="kw">nrow</span>(tmp2)), <span class="dt">cex=</span><span class="fl">0.5</span>)
  <span class="kw">points</span>(tmp2<span class="op">$</span>t[<span class="dv">1</span>], i, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">cex=</span><span class="fl">0.5</span>)
}</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-225-1.png" width="672" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(o <span class="op">~</span><span class="st"> </span>t, tmp, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Individuals&quot;</span>,
  <span class="dt">main=</span><span class="st">&quot;Vocalization events&quot;</span>, 
  <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(b<span class="op">$</span>nests)), <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="kw">max</span>(tint)))
<span class="cf">for</span> (j <span class="cf">in</span> <span class="kw">seq_along</span>(tint)) {
  ii &lt;-<span class="st"> </span><span class="cf">if</span> (j <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
    <span class="kw">c</span>(<span class="dv">0</span>, tint[j]) <span class="cf">else</span> <span class="kw">c</span>(tint[j<span class="dv">-1</span>], tint[j])
  vv &lt;-<span class="st"> </span>v[v<span class="op">$</span>t <span class="op">&gt;</span><span class="st"> </span>ii[<span class="dv">1</span>] <span class="op">&amp;</span><span class="st"> </span>v<span class="op">$</span>t <span class="op">&lt;=</span><span class="st"> </span>ii[<span class="dv">2</span>],]
  tmp &lt;-<span class="st"> </span>vv[<span class="op">!</span><span class="kw">duplicated</span>(vv<span class="op">$</span>i),]
  tmp<span class="op">$</span>o &lt;-<span class="st"> </span><span class="kw">seq_len</span>(<span class="kw">nrow</span>(tmp))
  <span class="cf">if</span> (<span class="kw">nrow</span>(tmp)) {
    <span class="cf">for</span> (i <span class="cf">in</span> tmp<span class="op">$</span>o) {
      tmp2 &lt;-<span class="st"> </span>vv[vv<span class="op">$</span>i <span class="op">==</span><span class="st"> </span>tmp<span class="op">$</span>i[i],]
      <span class="kw">lines</span>(<span class="kw">c</span>(tmp2<span class="op">$</span>t[<span class="dv">1</span>], ii[<span class="dv">2</span>]), <span class="kw">c</span>(i,i), <span class="dt">col=</span><span class="st">&quot;grey&quot;</span>)
      <span class="kw">points</span>(tmp2<span class="op">$</span>t, <span class="kw">rep</span>(i, <span class="kw">nrow</span>(tmp2)), <span class="dt">cex=</span><span class="fl">0.5</span>)
      <span class="kw">points</span>(tmp2<span class="op">$</span>t[<span class="dv">1</span>], i, <span class="dt">pch=</span><span class="dv">19</span>, <span class="dt">cex=</span><span class="fl">0.5</span>)
    }
  }
}</code></pre>
<p><img src="qpad-book_files/figure-html/unnamed-chunk-225-2.png" width="672" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(unmarked)

f &lt;-<span class="st"> </span><span class="cf">function</span>() {
  a &lt;-<span class="st"> </span><span class="kw">bsims_populate</span>(l, <span class="dt">density=</span>Den)
  b &lt;-<span class="st"> </span><span class="kw">bsims_animate</span>(a, <span class="dt">vocal_rate=</span>phi, <span class="dt">move_rate=</span><span class="dv">0</span>)
  tr &lt;-<span class="st"> </span><span class="kw">bsims_transcribe</span>(b, <span class="dt">tint=</span>tint)
  <span class="kw">drop</span>(tr<span class="op">$</span>visits)
}

Den &lt;-<span class="st"> </span><span class="fl">0.01</span>

<span class="co">#ymx &lt;- tr$visits</span>
(ymx &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">replicate</span>(<span class="dv">10</span>, <span class="kw">f</span>())))</code></pre>
<pre><code>##       0-1min 1-2min 2-3min 3-4min 4-5min
##  [1,]      0      0      0      0      0
##  [2,]      0      1      0      0      1
##  [3,]      0      2      2      1      0
##  [4,]      1      1      0      1      0
##  [5,]      0      0      0      0      0
##  [6,]      0      0      0      0      0
##  [7,]      2      2      0      1      0
##  [8,]      1      1      0      0      0
##  [9,]      0      0      0      0      0
## [10,]      0      1      0      1      0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">## highly dependent on K when Den is higher</span>
nmix &lt;-<span class="st"> </span><span class="kw">pcount</span>(<span class="op">~</span><span class="dv">1</span> <span class="op">~</span><span class="dv">1</span>, <span class="kw">unmarkedFramePCount</span>(<span class="dt">y=</span>ymx), <span class="dt">K=</span><span class="dv">1000</span>)
<span class="kw">coef</span>(nmix)</code></pre>
<pre><code>## lam(Int)   p(Int) 
## -0.02602 -0.44730</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plogis</span>(<span class="kw">coef</span>(nmix)[<span class="dv">2</span>])</code></pre>
<pre><code>## p(Int) 
##   0.39</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exp</span>(<span class="kw">coef</span>(nmix)[<span class="dv">1</span>])</code></pre>
<pre><code>## lam(Int) 
##   0.9743</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">Den <span class="op">*</span><span class="st"> </span><span class="dv">100</span></code></pre>
<pre><code>## [1] 1</code></pre>
<p>Mixture with JOSM</p>
<pre class="sourceCode r"><code class="sourceCode r">spp &lt;-<span class="st"> &quot;TEWA&quot;</span>

Y &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(yall[[spp]])
D &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">10</span>), <span class="kw">nrow</span>(Y), <span class="dv">3</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>,
  <span class="dt">dimnames=</span><span class="kw">dimnames</span>(Y))
X &lt;-<span class="st"> </span>josm<span class="op">$</span>surveys[<span class="kw">rownames</span>(Y), <span class="kw">c</span>(<span class="st">&quot;DAY&quot;</span>, <span class="st">&quot;TSSR&quot;</span>)]
ytot &lt;-<span class="st"> </span><span class="kw">rowSums</span>(Y)

Best &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="kw">rownames</span>(M_AIC)[M_AIC<span class="op">$</span>delta_AIC <span class="op">==</span><span class="st"> </span><span class="dv">0</span>])
<span class="kw">summary</span>(Best)</code></pre>
<pre><code>## 
## Call:
## cmulti(formula = Y | D ~ DAY, data = X, type = &quot;mix&quot;)
## 
## Removal Sampling (heterogeneous singing rate)
## Conditional Maximum Likelihood estimates
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## log.phi               -1.716      0.097  -17.69   &lt;2e-16 ***
## logit.c_(Intercept)   -2.070      0.692   -2.99   0.0028 ** 
## logit.c_DAY            4.804      1.558    3.08   0.0020 ** 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Log-likelihood: -3.1e+03 
## BIC = 6.22e+03</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">plogis</span>(<span class="kw">model.matrix</span>(Best) <span class="op">%*%</span><span class="st"> </span><span class="kw">coef</span>(Best)[<span class="op">-</span><span class="dv">1</span>]) <span class="op">*</span>
<span class="st">  </span><span class="kw">exp</span>(<span class="op">-</span><span class="dv">10</span> <span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="kw">coef</span>(Best)[<span class="dv">1</span>]))
<span class="kw">summary</span>(p)</code></pre>
<pre><code>##        V1       
##  Min.   :0.903  
##  1st Qu.:0.909  
##  Median :0.913  
##  Mean   :0.914  
##  3rd Qu.:0.919  
##  Max.   :0.925</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">glm</span>(ytot <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">family=</span>poisson, <span class="dt">offset=</span><span class="kw">log</span>(p))
<span class="kw">mean</span>(ytot)</code></pre>
<pre><code>## [1] 1.222</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exp</span>(<span class="kw">coef</span>(m))</code></pre>
<pre><code>## (Intercept) 
##       1.338</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(ytot <span class="op">/</span><span class="st"> </span>p)</code></pre>
<pre><code>## [1] 1.337</code></pre>
<p>This result tells us mean abundance after correcting for availability
bias, but we don’t know what area was effectively sampled,
and detection of individuals given availability is probably less than 1.
We shall address this problem in the next chapter.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="regression.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="detection.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook/js/app.min.js"></script>
<script src="libs/gitbook/js/lunr.js"></script>
<script src="libs/gitbook/js/plugin-search.js"></script>
<script src="libs/gitbook/js/plugin-sharing.js"></script>
<script src="libs/gitbook/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook/js/plugin-bookdown.js"></script>
<script src="libs/gitbook/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/psolymos/qpad-book/edit/master/04-behavior.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["qpad-book.pdf", "qpad-book.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
