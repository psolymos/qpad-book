# Behavioral Complexities {#behavior}

## Introduction

We have reviewed so far how to fit _naive_ models to estimate
the expected value of the observed counts, $\lambda$.
So what is this $\lambda$?
Here are some deifinitions for further discussion:

- **relative abundance**: $\lambda$ without any reference to nuisance variables, but possibly standardized by design, or nuisance variables used as fixed effects,
- **abundance**: $N=\lambda/C$, $C$ is a correction factor and $N$ refers to the number of individuals within the area surveyed -- the problem is that we cannot measure this directly (this is a latent variable), moreover the survey area is also often unknown (i.e. for unlimited distance counts),
- **occupancy**: the probability that the survey area is occupied, this is really equivalent to the indicator function $N>0$,
- **density** $D = N/A = \lambda/AC$, abundance per unit area -- same problems as above: both $N$ and $A$ are unknowns.

Our objective in the following chapters is to work out the details of 
estimating abundance and density in some clever ways through
learning about the nature of the mechanisms contributing to $C$.

## Prerequisites

```{r beh-libs,message=FALSE,warning=FALSE}
library(bSims)                # simulations
library(detect)               # multinomial models
source("functions.R")         # some useful stuff
load("_data/josm/josm.rda") # JOSM data
set.seed(1)
```

## A world with birds in it

Build a landscape: extent is given in 100 m units

```{r}
(l <- bsims_init(extent=10))
plot(l)
```

We have a 100 ha landscape that we populate with birds,
1 bird / ha using a Poisson spatial point process.
As a result, we have $N$ birds in the landscape,
$N \sim Poisson(\lambda)$, $\lambda = DA$:

```{r}
(a <- bsims_populate(l, density=0.5))
plot(a)
```

The locations can be seen as nest locations. But birds don't just
stay at one place. The move and vocalize:

```{r}
(b <- bsims_animate(a, 
  vocal_rate=0.5, duration=10,
  move_rate=1, movement=0.25))
plot(b)

```

```{r}
e <- get_events(b)
summary(e)
v <- get_events(b, vocal_only=TRUE)
```


```{r eval=FALSE}
## check vocal rates: no mixture
phi <- 0.5
br <- c(3, 5, 10)
#br <- 1:10
l <- bsims_init(10)
p <- bsims_populate(l, 1)
a <- bsims_animate(p, vocal_rate=phi)
o <- bsims_detect(a, tau=Inf) # detect all
d <- get_detections(o, first_only=TRUE)
i <- cut(d$t, c(0, br), include.lowest = TRUE)
table(i)
Y1 <- matrix(as.numeric(table(i)), nrow=1)
D1 <- matrix(br, nrow=1)
(phihat <- exp(cmulti.fit(Y1, D1, type="rem")$coef))
plot(stepfun(d$t, (0:nrow(d))/nrow(d)), do.points=FALSE, xlim=c(0,10))
curve(1-exp(-phi*x), add=TRUE, col=2)
points(br, cumsum(table(i))/sum(table(i)), cex=2, col=4)
curve(1-exp(-phihat*x), add=TRUE, col=4)

## check vocal rates: finite mixture
phi <- c(10, 0.5)
mix <- c(0.2, 0.8)
#br <- c(3, 5, 10)
br <- 1:10
l <- bsims_init(10)
p <- bsims_populate(l, 10)
a <- bsims_animate(p, vocal_rate=phi, mixture=mix)
o <- bsims_detect(a, tau=Inf) # detect all
d <- get_detections(o, first_only=TRUE)
i <- cut(d$t, c(0, br), include.lowest = TRUE)
table(i)
Y1 <- matrix(as.numeric(table(i)), nrow=1)
D1 <- matrix(br, nrow=1)
cf <- cmulti.fit(Y1, D1, type="mix")$coef # log.phi, logit.c
(phihat <- exp(cf[1]))
(mixhat <- c(1-plogis(cf[2]), plogis(cf[2])))


plot(stepfun(d$t, (0:nrow(d))/nrow(d)), do.points=FALSE, xlim=c(0,10))
curve(1-mix[2]*exp(-phi[2]*x), add=TRUE, col=2)
points(br, cumsum(table(i))/sum(table(i)), cex=2, col=4)
curve(1-mixhat[2]*exp(-phihat*x), add=TRUE, col=4)

# play with intervals
```

Need to explain survival models and removal model related stats

Here comes the real data analysis

Behaviour related stuff

constant p (time as covariate)

time varying p

finite mix

time varying p/c

rate, count, time-to-event

