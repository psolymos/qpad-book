# Miscellaneous Topics {#extras}

model selection and conditional likelihood

variance/bias trade off

error propagation

MCMC?

N-mixture ideas

phylogenetic and life history/trait stuff

PIF methods

## These are just reminders, to be deleted later {-}

You can label chapter and section titles using `{#label}` after them, e.g., we can reference Chapter \@ref(intro). If you do not manually label them, there will be automatic labels anyway.

Figures and tables with captions will be placed in `figure` and `table` environments, respectively.

```{r nice-fig, fig.cap='Here is a nice figure!', out.width='80%', fig.asp=.75, fig.align='center'}
par(mar = c(4, 4, .1, .1))
plot(pressure, type = 'b', pch = 19)
```

Reference a figure by its code chunk label with the `fig:` prefix, e.g., see Figure \@ref(fig:nice-fig). Similarly, you can reference tables generated from `knitr::kable()`, e.g., see Table \@ref(tab:nice-tab).

```{r nice-tab, tidy=FALSE}
knitr::kable(
  head(iris, 20), caption = 'Here is a nice table!',
  booktabs = TRUE
)
```

## Binomial model and censoring

Try cloglog with a rare species, like BOCH

```{r eval=FALSE}
#spp <- "OVEN" # which species
spp <- "BOCH" # which species
#spp <- "CAWA" # which species

x <- data.frame(
  josm$surveys, 
  y=as.numeric(ytot[rownames(x), spp]))
x$y01 <- ifelse(x$y > 0, 1, 0)

table(x$y)


mP <- glm(y ~ Decid * ConifWet, x, family=poisson)
mBc <- glm(y01 ~ Decid * ConifWet, x, family=binomial("cloglog"))
mBl <- glm(y01 ~ Decid * ConifWet, x, family=binomial("logit"))

coef(mP)
coef(mBc)
coef(mBl)

plot(fitted(mBc) ~ fitted(mP), col=4, 
  ylim=c(0, max(fitted(mP))), xlim=c(0, max(fitted(mP))))
points(exp(model.matrix(mBc) %*% coef(mBc)) ~ fitted(mP), col=2)
abline(0,1)
```

## Optimal partitioning

```{r regr-oc,cache=TRUE,eval=FALSE}
oc <- opticut(as.matrix(ytot) ~ 1, strata = x$HAB, dist="poisson")
plot(oc)
```



## Optilevels

When we have categorical or compositional (when e.g. proportions add up to 1, also called
the unit sum constraint) data,
we often want to simplify and merge classes or add up columns.
We can do this based on the structural understanding of these land cover classes
(call all treed classes Forest, like what we did for `FOR`, `WET` and `AHF`).

Alternatively, we can let the data (the birds) tell us how to merge the classes.
The algorithm does the following:

1. fit model with all classes,
2. order estimates for each class from smallest to largest,
3. merge classes that are near each others, 2 at a time, moving from smallest to largest,
4. compare $\Delta$AIC or $\Delta$BIC values for the merged models and pick the smallest,
5. treat this best merged model as an input in step 1 and star over until $\Delta$ is negative (no improvement).

Here is the code for simplifying categories using the `opticut::optilevels` function:

```{r regr-optilev1,eval=FALSE}
M <- model.matrix(~HAB-1, x)
colnames(M) <- levels(x$HAB)
ol1 <- optilevels(x$y, M, dist="poisson")
sort(exp(coef(bestmodel(ol1))))
## estimates
exp(ol1$coef)
## optimal classification
ol1$rank
data.frame(combined_levels=ol1$levels[[length(ol1$levels)]])
```

Here is the code for simplifying compositional data:

```{r regr-optilev2,eval=FALSE}
ol2 <- optilevels(x$y, x[,cn], dist="poisson")
sort(exp(coef(bestmodel(ol2))))
## estimates
exp(ol2$coef)
## optimal classification
ol2$rank
head(groupSums(as.matrix(x[,cn]), 2, ol2$levels[[length(ol2$levels)]]))
```


## N-mixture models

## Estimating abundance

Exponential model, bSims data

```{r}
set.seed(1)
phi <- 0.5
Den <- 1
l <- bsims_init()
a <- bsims_populate(l, density=Den)
b <- bsims_animate(a, vocal_rate=phi, move_rate=0)

tint <- 1:5
(tr <- bsims_transcribe(b, tint=tint))
```

Multiple-visit stuff for bSims: the counting of new individuals
resets for each interval (also: needs equal intervals)


```{r}
tr$visits

v <- get_events(b, vocal_only=TRUE)
v <- v[v$t <= max(tint),]
v1 <- v[!duplicated(v$i),]

tmp <- v1
tmp$o <- seq_len(nrow(v1))
plot(o ~ t, tmp, type="n", ylab="Individuals",
  main="Vocalization events", 
  ylim=c(1, nrow(b$nests)), xlim=c(0,max(tint)))
for (i in tmp$o) {
  tmp2 <- v[v$i == v1$i[i],]
  lines(c(tmp2$t[1], max(tint)), c(i,i), col="grey")
  points(tmp2$t, rep(i, nrow(tmp2)), cex=0.5)
  points(tmp2$t[1], i, pch=19, cex=0.5)
}


plot(o ~ t, tmp, type="n", ylab="Individuals",
  main="Vocalization events", 
  ylim=c(1, nrow(b$nests)), xlim=c(0,max(tint)))
for (j in seq_along(tint)) {
  ii <- if (j == 1)
    c(0, tint[j]) else c(tint[j-1], tint[j])
  vv <- v[v$t > ii[1] & v$t <= ii[2],]
  tmp <- vv[!duplicated(vv$i),]
  tmp$o <- seq_len(nrow(tmp))
  if (nrow(tmp)) {
    for (i in tmp$o) {
      tmp2 <- vv[vv$i == tmp$i[i],]
      lines(c(tmp2$t[1], ii[2]), c(i,i), col="grey")
      points(tmp2$t, rep(i, nrow(tmp2)), cex=0.5)
      points(tmp2$t[1], i, pch=19, cex=0.5)
    }
  }
}

library(unmarked)

f <- function() {
  a <- bsims_populate(l, density=Den)
  b <- bsims_animate(a, vocal_rate=phi, move_rate=0)
  tr <- bsims_transcribe(b, tint=tint)
  drop(tr$visits)
}

Den <- 0.01

#ymx <- tr$visits
(ymx <- t(replicate(10, f())))

## highly dependent on K when Den is higher
nmix <- pcount(~1 ~1, unmarkedFramePCount(y=ymx), K=1000)
coef(nmix)
plogis(coef(nmix)[2])
exp(coef(nmix)[1])
Den * 100

```


